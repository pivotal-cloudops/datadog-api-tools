#!/usr/bin/env ruby
require 'json'
require 'dogapi'
require 'colorize'
require 'rationalist' # Simple option parser

def check_datadog_key(key)
  unless key
    puts "$DATADOG_KEY is required for this tool to function! Please set it.".red
    exit 1
  end
end

def hash_from_stdin
  begin
    input_hash = JSON.parse($stdin.read)
  rescue JSON::ParserError => e
    puts "Receieved a error parsing the JSON given: #{e}".red
    exit 1
  end

  input_hash
end

def additional_tags_array(tag_string)
  tag_string.split(',')
end

def help
  puts "Usage: #{$0}"
  puts "Options:"
  puts "  --metric           Name of the metric to store in datadog"
  puts "  --tag-prefix       Namespace prefix for metric tag"
  puts "  --verbose          Enable verbose output"
  puts "  --api-key          Your datadog api key (can also be set as $DATADOG_KEY)"
  puts "  --additional-tags  A list of additional tags you want to send, formatted like 'environment:prod,foo:bar'"
end


argv = Rationalist.parse(ARGV)


if ARGV.empty?
  help
  exit 1
end


metric_name = argv[:metric]
tag_prefix = argv[:'tag-prefix']
verbose = argv[:verbose] || argv[:v]
help_requested = argv[:help] || argv[:h]
datadog_api_key = argv[:'api-key'] || ENV["DATADOG_KEY"]
additional_tag_argument = argv[:'additional-tags']

if help_requested
  help
  exit 0
end

check_datadog_key(datadog_api_key)

tags = additional_tags_array(additional_tag_argument) if additional_tag_argument

dog = Dogapi::Client.new(datadog_api_key)
threads = []

hash_from_stdin.each do |tag, count|
  threads << Thread.new do
    tag = "#{tag_prefix}:#{tag}" if tag_prefix
    tags << tag
    response = dog.emit_point(metric_name, count, tags: tags)

    status = response.first.to_i

    if status > 100 && status < 300
      Thread.current[:message] = "#{tag}: work completed.".green if verbose
    else
      Thread.current[:message] = "#{tag}: received a non-200 status code: #{response}".red if verbose
    end
  end
end

threads.each do |thread|
  thread.join
  puts thread[:message] if thread[:message]
end
